### 자바 성능 튜닝 이야기

#### 1. 디자인 패턴
1. MVC 패턴
   - model 
   - view 
   - controller
2. J2EE 패턴 (java 2 enterprise edition)
   - MVC 패턴의 구조가 기본으로 깔려있다
   - 웹 어플리케이션 서버에서 동작하는 장애복구 및 분산 멀티미어 제공하는 자바 소프트웨어 기능을 추가한 서버를 위한 플랫폼
#### 2. 내가 만든 프로그램의 속도를 알고 싶다
   - 툴을 사용해서 테스트 해볼수있다
          1. APM, 프로파일링 툴 (유료)
          2. 가볍게 테스트 : System 클래스 (무료)
              - System 은 Class이다 static으로 명시되어있다. System 객체를 생성할 수 없다.
              - System.currentTimeMills(현재 시간 리턴)와 System.nanoTime (시간 측정 사용이므로, 오늘 날짜를 알내는 용도로는 사용 못함)
              - JMH(java microbenchmark harness : jdk를 오픈 소스로 제공하는 openJDK에서 만든 라이브러리)
                  - 여러 스레드로 테스트 가능, 굵은 글자로 표현된것만 확인하면 된다
                  - min, avg, max, stdev(표준편차:평균을 중심으로 얼마나 떨어져있는지 값 표현. 수치가 적을수록 평균값이 가깝다는 뜻)
#### 3. 왜 자꾸 String을 쓰지 말라는거야?
1. String은 잘 사용하면 상관이 없지만, 잘못 사용하면 메모리에 영향을 많이준다 (String을 많이 사용하면 GC가 많이 발생한다. 쿼리 생성할때 String 으로 된 문자열을 더하는것이다.) 그 이유는?
   1. 우선 이 얘기를 하기전에, java.lang.Object(클래스 확장)를 제외하고 가장많이 사용하는 객체가 무엇일까?
      - 1위는 String 클래스, 2위 Collection 관련 클래스이다
2. StringBuilder 클래스 StringBuffer 클래스
   - jdk 5버전 기준으로 문자열을 만드는 클래스는 String, StringBuilder, StringBuffer을 가장 많이 사용한다.  그 둘의 차이점은 무엇일까?
       1. StringBuffer 클래스는 안전하게(ThreadSafe) 설계되어있어서 여러개의 스레드에서 하나의 StringBuffer 객체를 처리해도 전혀 문제가 되지 않는다
       2. StringBuilder는 단일 스레드에서만 안전성을 보장 받는다. 그래서 여러개 스레드에서 하나의 StringBuilder를 처리하면 문제가 발생한다
3. 아래 코드를 보면 왜 이렇게 응답시간과 메모리 사용량 차이가 많을까?

```
String strSql = "";
strSql += "select * ";
strSql += "from ";
...
// 응답시간 : 10 회 약 5ms
// 메모리 사용량 : 10회 평균 약 5MB
```
```
StringBuilder strSql = new StringBuilder;
strSql.append("select * ");
strSql.append("from");
...
// 응답시간 : 10회 약 0.3ms
// 메모리 사용량 : 10회 평균 약 371KB
```

- String, StringBuffer, StringBuilder 메모리에서 어떻게 생성되는지 비교해보자
    - String

        | 주소 | String value          |
        | --- |-----------------------|
        | 100 | abcde                 |
        | 150 | abcde + abcde         |
        | 200 | abcde + abcde + abcde |
    
    - StringBuilder, StringBuffer

        | 주소 | String value          |
        | --- |-----------------------|
        | 100 | abcde                 |
        | 100 | abcde + abcde         |
        | 100 | abcde + abcde + abcde |
    - 위에서 보면 ‘String’ 같은 경우에는 주소를 다시 할당 받아서 값을 추가 한 내용을 객체를 다시 생성한다 또 새로운 객체를 생성하고 계속 반복할것이다. 그러면 메모리를 많이 사용하게 되고 응답속도에도 영향을 미치게된다. GC를 하면 할수록 시스템의 CPU를 사용하게 되고 시간도 많이 소요하게 된다.
    - 위에서 보면 StringBuilder, StringBuffer 는 같은 메모리를 사용하여 객체의 크기를 증가시키면서 값을 더한다
    - 뭐 그렇다고 꼭 String이 나쁜것은 아니다 역할에 맞춰 사용하면 된다
        - String : 짧은 문자열 사용할때 사용한다
        - StringBuilder : 스레드에 안전한지 관계 없을때 사용한다
        - StringBuffer: 스레드에 안전하게 사용해야할때. 싱글톤일때 사용 권장 한다
#### 4. 어디에 담아야하는지…
#### 5. 지금까지 사용하던 for 루프를 더 빠르게 할 수 있다고?
#### 6. static 제대로 한번 써보자
#### 7. 클래스 정보, 어떻게 알아낼 수 있나?
#### 8. synchronized는 제대로 알고 써야 한다
#### 9. IO에서 발생하는 병목 현상
#### 10. 로그는 반드시 필요한 내용만 찍자
#### 11. JSP와 서블릿, Spring에서 발생할 수 있는 여러 문제점
#### 12. DB를 사용하면서 발생 가능한 문제점들
#### 13. XML과 JSON도 잘 쓰자
#### 14. 서버를 어떻게 세팅해야할까?
#### 15. 안드로이드 개발하면서 이것만큼은 피하자
#### 16. JVM은 도대체 어떻게 구동될까?
#### 17. 도대체 GC는 언제 발생할까?
#### 18. GC가 어떻게 수행되고 있는지 보고 싶다
#### 19. GC 튜닝을 항상 할 필요는 없다
#### 20. 모니터링 API인 JMX
#### 21. 반드시 튜닝해야 하는 대상은?
#### 22. 어떤 화면이 많이 쓰이는지 알고 싶다
#### 23. 튜닝의 절차는 그때그때 달라요
#### 24. 애플리케이션에서 점검해야 할 사항들

<hr>

### 최적화 관련

#### Q. 캐시와 메모리 성능의 균형은 어떻게 맞추는가?
캐시를 사용할 때는 메모리 용량과 캐시 만료 정책을 잘 조절해야 합니다. 예를 들어, 자주 사용되는 데이터는 캐시에 저장하고, 타임아웃 설정을 통해 오래된 데이터를 자동으로 삭제하도록 합니다. 또한, 캐시 크기를 제한하여 메모리 과부하를 방지하고, 필요한 데이터만 캐시하도록 처리하여 성능과 메모리 사용의 균형을 맞춥니다

#### Q. 객체 생성이 많은 상황에서 메모리 최적화 방안은?
객체 생성이 많은 상황에서는 메모리 사용량을 줄이기 위해 객체 풀링(Object Pooling) 기법을 사용할 수 있습니다. 자주 사용되는 객체는 미리 생성해 놓고 재사용하도록 하여, 매번 새로운 객체를 생성하는 비용을 줄이고 메모리 할당을 최소화합니다. 또한, 불필요한 객체의 생성을 피하고, 객체가 더 이상 필요하지 않으면 명시적으로 메모리 해제를 유도합니다. 이와 함께, **불변 객체(Immutable Objects)**를 사용하는 것도 좋은 방법으로, 불변 객체는 상태 변경이 없으므로 새 객체 생성 비용을 줄이고 메모리 효율성을 높일 수 있습니다.

#### Q. 스택과 힙의 차이점은?
스택은 메서드 실행 시 생성되는 지역 변수나 호출 정보가 저장되며, 메서드 호출이 끝나면 자동으로 제거되는 구조입니다. 반면 힙은 객체가 동적으로 할당되는 영역으로, 명시적으로 해제하지 않으면 가비지 컬렉터에 의해 관리됩니다.

#### Q. 가비지 컬렉션(GC)이란 무엇인가?
GC는 사용하지 않는 객체를 메모리에서 자동으로 정리해주는 자바의 메모리 관리 방식입니다.

#### Q. 메모리 누수란 무엇인가?
메모리 누수는 프로그램이 더 이상 사용하지 않는 메모리를 해제하지 않아서 메모리가 계속 남아 있는 상태를 말합니다. 프로그램이 실행되면서 메모리를 동적으로 할당하고, 더 이상 그 메모리를 사용하지 않으면 적절하게 해제해야 하는데, 이를 하지 않으면 불필요한 메모리가 계속 쌓이게 되어 시스템 자원이 낭비되고, 결국 시스템 성능 저하나 프로그램 크래시(충돌)로 이어질 수 있습니다.

#### Q. 동적 메모리 할당 vs 정적 메모리 할당
정적 메모리는 컴파일 타임에 크기와 위치가 고정되며, 예를 들어 배열 같은 경우 선언 시 크기를 고정해야 합니다. 동적 메모리는 런타임 중에 필요한 만큼 할당되며, Java에서는 new 키워드를 통해 객체 생성 시 힙에 할당됩니다.

- 언어/환경 관련
  #### Q. Java/Spring의 메모리 구조 (Heap, Metaspace 등)에 대해 설명해 주세요.
  Java는 크게 Heap, Stack, Metaspace 등으로 메모리를 나눕니다. Heap은 객체가 저장되는 공간, Stack은 메서드 실행 중의 지역 변수 공간입니다. Metaspace는 클래스 메타데이터가 저장되는 곳으로, 예전 PermGen에서 변경된 부분입니다.
  이제는 heap 영역이 아니라 native 메모리 영역에 위치합니다.
  힙(Heap)과 스택(Stack)은 Java 프로그램에서 데이터와 변수들을 저장하는 메모리 영역입니다.

#### Q. heap, Stack 에 대해서 더 설명해주세요.
힙(Heap): 객체나 배열 같은 동적 데이터를 저장하는 공간. 가비지 컬렉터가 관리하고, 여러 스레드가 공유합니다.
스택(Stack): 함수의 지역 변수와 메서드 호출 정보를 저장하는 공간. 함수가 종료되면 자동으로 메모리가 해제됩니다.
Metaspace는 Java 8부터 도입된 메모리 영역으로, 클래스의 메타데이터(클래스 정보, 메서드, 필드 등)를 저장하는 공간입니다. 이전에는 PermGen이었고, 더 이상 힙이나 스택에 포함되지 않으며, 동적으로 크기가 조정됩니다.

#### Q. PHP에서 메모리 최적화를 어떻게 하나요?
PHP에서는 큰 배열이나 파일 처리 시 메모리 부족 문제가 발생하기 쉬운데, 실무에서는 데이터 처리 시 DB에서 데이터를 스트리밍 처리하는 방식으로 해결했습니다. 또한 이전에 엑셀 다운로드 작업 해본 적이 있는데, 메모리 부족으로 이슈가 발생했었을때는 ini_set()으로 메모리 제한을 조절한 경험도 있습니다.

#### Q. R2DBC에서 메모리 관리 주의할 점은?
R2DBC는 논블로킹 기반이라 결과 처리를 지연하거나 람다 내부에서 객체를 계속 참조하게 되면 메모리 누수가 생길 수 있습니다. Flux나 Mono 사용 시 .doOnDiscard() 같은 메서드를 통해 불필요한 참조를 제거했고, 리액티브 체인을 잘 정리해서 메모리 효율을 유지하려 노력했습니다.

#### Q. Java/Spring의 메모리 구조 (Heap, Metaspace 등)에 대해 설명해 주세요.
Java는 크게 Heap, Stack, Metaspace 등으로 메모리를 나눕니다. Heap은 객체가 저장되는 공간, Stack은 메서드 실행 중의 지역 변수 공간입니다. Metaspace는 클래스 메타데이터가 저장되는 곳으로, 예전 PermGen에서 변경된 부분입니다.
이제는 heap 영역이 아니라 native 메모리 영역에 위치합니다.
힙(Heap)과 스택(Stack)은 Java 프로그램에서 데이터와 변수들을 저장하는 메모리 영역입니다.

#### Q. heap, Stack 에 대해서 더 설명해주세요.
힙(Heap): 객체나 배열 같은 동적 데이터를 저장하는 공간. 가비지 컬렉터가 관리하고, 여러 스레드가 공유합니다.
스택(Stack): 함수의 지역 변수와 메서드 호출 정보를 저장하는 공간. 함수가 종료되면 자동으로 메모리가 해제됩니다.
Metaspace는 Java 8부터 도입된 메모리 영역으로, 클래스의 메타데이터(클래스 정보, 메서드, 필드 등)를 저장하는 공간입니다. 이전에는 PermGen이었고, 더 이상 힙이나 스택에 포함되지 않으며, 동적으로 크기가 조정됩니다.

#### Q. PHP에서 메모리 최적화를 어떻게 하나요?
PHP에서는 큰 배열이나 파일 처리 시 메모리 부족 문제가 발생하기 쉬운데, 실무에서는 데이터 처리 시 DB에서 데이터를 스트리밍 처리하는 방식으로 해결했습니다. 또한 이전에 엑셀 다운로드 작업 해본 적이 있는데, 메모리 부족으로 이슈가 발생했었을때는 ini_set()으로 메모리 제한을 조절한 경험도 있습니다.

#### Q. R2DBC에서 메모리 관리 주의할 점은?
R2DBC는 논블로킹 기반이라 결과 처리를 지연하거나 람다 내부에서 객체를 계속 참조하게 되면 메모리 누수가 생길 수 있습니다. Flux나 Mono 사용 시 .doOnDiscard() 같은 메서드를 통해 불필요한 참조를 제거했고, 리액티브 체인을 잘 정리해서 메모리 효율을 유지하려 노력했습니다.

#### Q. 메모리 부족 문제가 발생한 경험이 있다면?
네, 메모리 부족 문제를 직접 겪은 경험이 있습니다. PHP로 관리자 페이지에서 대량 데이터를 포함한 엑셀 파일을 다운로드하는 기능을 구현했을 때였는데, 수만 건 이상의 데이터를 한 번에 메모리에 올려서 처리하다 보니 메모리 사용량이 급격히 증가했고, 결국 PHP의 메모리 제한에 걸려 에러가 발생했습니다. 처음에는 단순히 ini_set 사용하여 메모리 제한을 해제해봤지만, 이건 근본적인 해결이 아니라고 판단해서 개선을 진행했습니다. 당시 해결을 위해 두 가지 전략을 사용했습니다. 스트리밍 방식으로 처리: 엑셀 데이터를 메모리에 전부 올리지 않고, PhpSpreadsheet 라이브러리에서 제공하는 출력 스트림으로 바로 전송하게처리 하여 다운로드하도록 변경했습니다. 또한, 25만건 정도 되는 데이터다 보니, 한번에 전체 데이터를 불러 오지 않고, 5000건씩 나눠서 처리합니다. 이 덕분에 메모리 사용량이 매우 일정하게 유지됐고, 수십만 건의 데이터도 문제없이 엑셀로 다운로드할 수 있었습니다.

이 경험을 통해 메모리 사용을 줄이기 위한 스트리밍 처리나 지연 로딩 방식의 중요성을 체감했고, 이후 대용량 처리 작업을 할 때 항상 메모리 사용량을 고려하고 있습니다.

#### Q. 메모리 릭 디버깅 경험이 있는가?
네, 직접 디버깅하고 해결한 경험이 있습니다. PHP로 대량 사용자 데이터를 엑셀로 다운로드하는 기능을 구현했을 때인데, 처음에는 단순하게 전체 데이터를 모두 메모리에 올려서 fputcsv()로 출력하는 방식이었습니다. 테스트 환경에서는 문제가 없었지만, 실제 운영 환경에서 수십만 건을 처리하다 보니 메모리 사용량이 계속 증가했고, 몇 번의 요청 후에는 Out of memory 오류가 발생했습니다. 단순한 메모리 부족이 아니라, 요청이 끝난 후에도 메모리가 회수되지 않는 현상이 있어, 이는 메모리 릭(leak) 가능성을 의심하게 됐습니다.

원인을 추적하면서 알게 된 건, 데이터 처리 도중 참조를 끊지 않고 계속 쌓는 로직이 있었고, 특히 일부 사용자 관련 추가 정보 객체가 루프 외부에서 참조된 상태로 남아 있어서 GC가 수거하지 못하는 상황이 있었습니다. 이 문제를 해결하기 위해 데이터를 5,000건 단위로 chunk()로 분할해서 반복 처리하고,각 루프가 끝날 때마다 불필요한 참조를 unset()으로 명시적으로 제거하거나, 가능하면 php://output 스트림을 사용해서 파일을 실시간으로 출력하고, 전체 데이터를 메모리에 유지하지 않도록 개선했습니다. 이후 테스트 결과, 메모리 사용량이 일정하게 유지되고 릭이 발생하지 않는 것을 확인할 수 있었고, 실제 운영 환경에서도 안정적으로 동작했습니다. 이 경험을 통해 명시적인 참조 해제의 중요성과 반복 구조 안에서 메모리 누수가 발생할 수 있는 패턴을 확실히 체감하게 됐습니다.

*메모리 릭이란. (memory leak)
컴퓨터 프로그맹이 필요하지 않은 메모리를 계속 점유하고 있는 현상을 말한다. 할당된 메모리를 반환하지 않는것이 누적되면 메모리 낭비 된다.

#### Q. 대용량 데이터를 다룰 때 메모리 부담을 줄이기 위한 방식은?
대용량 데이터를 처리할 때는 데이터를 한 번에 메모리에 올리지 않고, 일정 크기씩 나누어 처리하는 방식(예: chunk() 사용)을 선호합니다. 또한, **실시간 스트리밍 처리**를 통해 메모리 부담을 줄이고, 불필요한 참조는 명시적으로 해제하여 메모리 사용을 최소화합니다. 이를 통해 서버 자원 소모를 줄이고 안정적인 처리가 가능합니다.

#### Q. empty와 null의 차이 (메모리 관점)
null: 메모리 공간이 할당되지 않은 상태. 객체를 참조하고 있지 않으며, 해당 포인터는 유효한 공간을 가리키지 않음.
empty: 메모리에 객체는 할당되어 있으나, 그 내부 값이 비어 있는 상태. 예: 빈 문자열 "", 빈 리스트 [].
null = 존재하지 않음 (주소 없음)
empty = 존재하지만 내용 없음 (주소 있음)

#### Q. MVC 패턴 (클라이언트~서버 흐름)
Client: 사용자의 요청 (예: 버튼 클릭) → HTTP 요청 발생
Controller: 요청을 받아 적절한 서비스 호출, 처리 결과를 View에 전달
Model: 비즈니스 로직, DB 접근 등 핵심 기능 수행
View: 처리 결과를 사용자에게 보여줌 (HTML, JSON 등)
Client: 서버의 응답을 수신하고 화면에 표시
→ 역할을 분리하여 유지보수성과 테스트 용이성을 확보

#### Q. 싱글톤 패턴
정의: 클래스의 인스턴스를 오직 하나만 생성하고, 이를 전역적으로 공유하는 패턴
메모리 관점: 메모리에 한 번만 객체를 생성해 메모리 낭비 방지
활용: 설정 관리 객체, DB 연결, 로깅 등
주의: 멀티스레드 환경에서 동기화 필수 (Lazy Initialization 시)

#### Q. 동시성 (Concurrency)
여러 작업을 동시에 처리하는 것처럼 보이게 하는 기술
하나의 CPU에서 작업을 번갈아 실행하거나, 멀티코어에서 병렬 처리
문제점: 공유 자원 접근 시 Race Condition, Deadlock 발생 가능 → Lock, synchronized 등으로 해결

#### Q. DDD (Domain-Driven Design)
복잡한 비즈니스 로직을 도메인 중심으로 모델링
목적: 현실의 도메인을 개발 언어로 잘 표현하기 위함

#### Q. MSA (Microservice Architecture)
애플리케이션을 작은 단위의 독립된 서비스로 나누는 구조
각 서비스는 독립적으로 배포, 개발, 확장 가능
일반적으로 REST API, gRPC, Kafka 등을 통해 통신

장점: 독립성, 확장성
단점: 복잡성 증가, 데이터 일관성 문제, DevOps 필요

#### Q. DDD vs MSA
항목   DDD설계   MSA아키텍처
개념   소프트웨어 설계 접근 방식 /  소프트웨어 아키텍처 스타일
초점   도메인 모델링, 비즈니스 중심 설계 /  서비스 분리, 독립 배포
적용 범위   하나의 서비스 내부 구조  / 시스템 전체 구성
관계   MSA의 각 서비스 내부에 DDD를 적용할 수 있음

#### Q. 변수란? (메모리 관점)
변수는 값을 저장하기 위한 메모리 공간에 부여된 이름
스택: 지역 변수 저장, 함수 호출 시 메모리 자동 관리
힙: 동적 객체 저장, GC가 메모리 관리
변수는 데이터와 메모리 주소 간의 연결 고리

#### Q. Bean이란? (Spring 기준)
Spring IoC 컨테이너에 의해 생성되고 관리되는 객체
개발자가 직접 인스턴스를 생성하지 않고, Spring이 생성 → 의존성 주입(Dependency Injection) 가능
생명주기 관리: 생성 → 초기화 → 사용 → 소멸 전 처리

등록 방법:
클래스 위에 
```
@Component, @Service, @Repository, @Controller
또는 @Bean 메서드로 수동 등록
```
